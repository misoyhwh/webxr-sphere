<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebXR Shader Kaleidoscope Space</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
      import { XRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/webxr/XRButton.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // WebXR 設定
      renderer.xr.enabled = true;
      renderer.xr.setReferenceSpaceType('local'); // より自由な頭部トラッキング
      
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(XRButton.createButton(renderer));

      // カメラの初期位置を設定（WebXR時には自動的にトラッキング位置に置き換わる）
      camera.position.set(0, 1.6, 0); // 平均的な目の高さ

      // シェーダーマテリアル用のユニフォーム
      const uniforms = {
        u_time: { value: 0.0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
      };

      // バーテックスシェーダー
      const vertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      // フラグメントシェーダー（GLSLコードを組み込み）
      const fragmentShader = `
        uniform float u_time;
        uniform vec2 u_resolution;
        varying vec2 vUv;

        // 3D回転行列
        mat3 rotate3D(float angle, vec3 axis) {
          axis = normalize(axis);
          float s = sin(angle);
          float c = cos(angle);
          float oc = 1.0 - c;
          
          return mat3(
            oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
            oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
            oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
          );
        }

        void main() {
          vec2 FC = gl_FragCoord.xy;
          vec2 r = u_resolution;
          float t = u_time;
          vec4 o = vec4(0.0);
          
          // 元のGLSLコードを適応
          vec3 p = vec3((FC.xy * 2.0 - r) / r.y, 1.0) * rotate3D(t * 0.1, vec3(1.0));
          vec3 q;
          float i = 0.0;
          float d = 0.0;
          float g = 0.0;
          
          for(int iter = 0; iter < 99; iter++) {
            i += 1.0;
            if(i >= 99.0) break;
            
            q = normalize(p) * g;
            q.y += pow(sin(t + q.z), 3.0);
            
            vec3 modQ = mod(q - vec3(0.0, 0.0, t), 4.0) - 2.0;
            vec3 maxVec = max(abs(modQ) - 0.7, 0.0);
            g += length(maxVec);
            
            o = vec4(g) * 0.06 * vec4(0.2, p.y * 0.1, p.z * 0.4, 1.0);
          }
          
          // 色の調整
          o.rgb = pow(o.rgb, vec3(0.8)); // ガンマ補正
          o.rgb *= 2.0; // 明度アップ
          
          gl_FragColor = vec4(o.rgb, 1.0);
        }
      `;

      // 視界全体を覆う大きな球体を作成
      const sphereGeometry = new THREE.SphereGeometry(100, 64, 64); // 半径を小さく調整
      const shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.BackSide // 内側から見えるように
      });

      const sphere = new THREE.Mesh(sphereGeometry, shaderMaterial);
      scene.add(sphere);

      // 追加のオブジェクト（オプション）
      const objects = [];

      function getRandomColor() {
        return new THREE.Color(Math.random(), Math.random(), Math.random());
      }

      function createRandomObject() {
        const types = ['sphere', 'cube', 'torus'];
        const type = types[Math.floor(Math.random() * types.length)];
        let geometry;

        const scale = Math.random() * 0.3 + 0.1;

        switch (type) {
          case 'sphere':
            geometry = new THREE.SphereGeometry(scale, 16, 16);
            break;
          case 'cube':
            geometry = new THREE.BoxGeometry(scale, scale, scale);
            break;
          case 'torus':
            geometry = new THREE.TorusGeometry(scale, scale / 4, 16, 100);
            break;
        }

        const color = getRandomColor();
        const material = new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 1.5,
          roughness: 0.3,
          metalness: 0.2,
          transparent: true,
          opacity: 0.7
        });

        const mesh = new THREE.Mesh(geometry, material);

        // ランダムな位置と移動パラメータ
        mesh.position.set(
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 20
        );

        mesh.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.02,
          (Math.random() - 0.5) * 0.02,
          (Math.random() - 0.5) * 0.02
        );

        scene.add(mesh);
        objects.push(mesh);
      }

      // いくつかのオブジェクトを追加
      for (let i = 0; i < 30; i++) {
        createRandomObject();
      }

      // 照明
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      // アニメーション
      const clock = new THREE.Clock();

      // WebXRセッションの開始/終了イベント
      renderer.xr.addEventListener('sessionstart', () => {
        console.log('WebXR session started');
      });

      renderer.xr.addEventListener('sessionend', () => {
        console.log('WebXR session ended');
      });

      renderer.setAnimationLoop(() => {
        const elapsedTime = clock.getElapsedTime();
        
        // シェーダーの時間を更新
        uniforms.u_time.value = elapsedTime;

        // WebXR時とデスクトップ時の両方に対応
        if (renderer.xr.isPresenting) {
          // VR中：ヘッドトラッキングが自動的に適用される
          // 追加のカメラ制御は不要
        } else {
          // デスクトップ時：マウスでの簡易カメラ制御（オプション）
          // 必要に応じてOrbitControlsなどを追加可能
        }

        // オブジェクトのアニメーション
        objects.forEach((obj) => {
          obj.rotation.x += 0.01;
          obj.rotation.y += 0.015;
          obj.position.add(obj.userData.velocity);

          // 境界でバウンス
          if (Math.abs(obj.position.x) > 10) obj.userData.velocity.x *= -1;
          if (Math.abs(obj.position.y) > 10) obj.userData.velocity.y *= -1;
          if (Math.abs(obj.position.z) > 10) obj.userData.velocity.z *= -1;
        });

        renderer.render(scene, camera);
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // 解像度ユニフォームを更新
        uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>