<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebXR Kaleidoscope Space</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
      import { XRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/webxr/XRButton.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Web XR
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(XRButton.createButton(renderer));

      // 照明
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(0, 5, 0);
      scene.add(pointLight);

      const objects = [];

      function getRandomColor() {
        return new THREE.Color(Math.random(), Math.random(), Math.random());
      }

function createRandomObject() {
  // 様々な図形タイプ
  const types = ['sphere', 'cube', 'torus', 'cone', 'cylinder', 'octahedron'];
  const type = types[Math.floor(Math.random() * types.length)];
  let geometry;

  // 様々な大きさ
  const scale = Math.random() * 0.8 + 0.1; // 0.1 〜 0.9

  switch (type) {
    case 'sphere':
      geometry = new THREE.SphereGeometry(scale, 16, 16);
      break;
    case 'cube':
      geometry = new THREE.BoxGeometry(scale, scale, scale);
      break;
    case 'torus':
      geometry = new THREE.TorusGeometry(scale, scale / 4, 16, 100);
      break;
    case 'cone':
      geometry = new THREE.ConeGeometry(scale, scale * 1.5, 16);
      break;
    case 'cylinder':
      geometry = new THREE.CylinderGeometry(scale, scale, scale * 1.2, 16);
      break;
    case 'octahedron':
      geometry = new THREE.OctahedronGeometry(scale);
      break;
  }

  const color = getRandomColor();
  const material = new THREE.MeshStandardMaterial({
    color: color,
    emissive: color,
    emissiveIntensity: Math.random() * 2 + 0.5, // 0.5 〜 2.5の光り具合
    roughness: 0.3,
    metalness: 0.2,
  });

  const mesh = new THREE.Mesh(geometry, material);

  // 円弧飛行用のパラメータを設定
  mesh.userData = {
    // 円弧の中心点
    centerX: (Math.random() - 0.5) * 10,
    centerY: (Math.random() - 0.5) * 5,
    centerZ: (Math.random() - 0.5) * 10,
    
    // 円弧の半径
    radius: Math.random() * 3 + 1, // 1 〜 4
    
    // 回転速度（円弧を描く速度）
    orbitSpeed: (Math.random() - 0.5) * 0.05, // -0.025 〜 0.025
    
    // 現在の角度
    angle: Math.random() * Math.PI * 2,
    
    // Y軸方向の振動
    yOffset: Math.random() * 2,
    ySpeed: (Math.random() - 0.5) * 0.03,
    
    // Z軸方向の変化
    zSpeed: (Math.random() - 0.5) * 0.02
  };

  // 初期位置を計算
  const x = mesh.userData.centerX + Math.cos(mesh.userData.angle) * mesh.userData.radius;
  const y = mesh.userData.centerY + mesh.userData.yOffset;
  const z = mesh.userData.centerZ + Math.sin(mesh.userData.angle) * mesh.userData.radius;
  
  mesh.position.set(x, y, z);

  scene.add(mesh);
  objects.push(mesh);
}

// たくさん生成（50個程度）
for (let i = 0; i < 50; i++) {
  createRandomObject();
}

      // 生成
      createRandomObject();

      // アニメーション
renderer.setAnimationLoop(() => {
  objects.forEach((obj) => {
    // 自転
    obj.rotation.x += 0.02;
    obj.rotation.y += 0.01;
    obj.rotation.z += 0.015;
    
    // 円弧軌道の更新
    obj.userData.angle += obj.userData.orbitSpeed;
    obj.userData.yOffset += obj.userData.ySpeed;
    
    // 新しい位置を計算
    const x = obj.userData.centerX + Math.cos(obj.userData.angle) * obj.userData.radius;
    const y = obj.userData.centerY + obj.userData.yOffset + Math.sin(obj.userData.angle * 2) * 0.5;
    const z = obj.userData.centerZ + Math.sin(obj.userData.angle) * obj.userData.radius;
    
    obj.position.set(x, y, z);
    
    // Y方向の振動を制限
    if (Math.abs(obj.userData.yOffset) > 3) {
      obj.userData.ySpeed *= -1;
    }
    
    // 万華鏡効果（オプション）
    if (obj.position.length() > 12) {
      obj.userData.centerX *= -0.8;
      obj.userData.centerY *= -0.8;
      obj.userData.centerZ *= -0.8;
    }
  });

  renderer.render(scene, camera);
});

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
